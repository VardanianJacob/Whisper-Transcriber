<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Audio Transcription</title>
  <!-- Official Telegram WebApp SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    :root {
      --primary-color: #2196F3;
      --primary-hover: #1976D2;
      --success-color: #4CAF50;
      --success-hover: #45a049;
      --error-color: #f44336;
      --background-color: #f6f6f6;
      --card-background: #ffffff;
      --text-color: #333333;
      --border-color: #dddddd;
      --secondary-bg: #6c757d;
      --secondary-hover: #5a6268;
      --claude-color: #6366f1;
      --claude-hover: #4f46e5;
    }

    /* –¢–µ–º–Ω–∞—è —Ç–µ–º–∞ –¥–ª—è Telegram */
    [data-theme="dark"] {
      --primary-color: #2196F3;
      --primary-hover: #1976D2;
      --success-color: #4CAF50;
      --success-hover: #45a049;
      --error-color: #f44336;
      --background-color: #1a1a1a;
      --card-background: #2a2a2a;
      --text-color: #ffffff;
      --border-color: #444444;
      --secondary-bg: #495057;
      --secondary-hover: #3d4449;
      --claude-color: #8b5cf6;
      --claude-hover: #7c3aed;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      padding: 20px;
      background: var(--background-color);
      color: var(--text-color);
      margin: 0;
      line-height: 1.5;
    }

    .container {
      background: var(--card-background);
      padding: 24px;
      border-radius: 12px;
      max-width: 600px;
      margin: 0 auto;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    }

    h2 {
      margin: 0 0 24px 0;
      color: var(--text-color);
      font-size: 1.5em;
    }

    .form-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: var(--text-color);
    }

    input[type="text"],
    input[type="file"],
    input[type="number"],
    select,
    textarea {
      width: 100%;
      padding: 12px;
      border: 2px solid var(--border-color);
      border-radius: 8px;
      font-size: 16px;
      transition: border-color 0.3s ease;
      background: var(--card-background);
      color: var(--text-color);
    }

    input[type="file"] {
      padding: 8px;
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: var(--primary-color);
    }

    input[type="checkbox"] {
      width: auto;
      margin-right: 8px;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      margin-top: 8px;
    }

    .btn {
      padding: 12px 24px;
      margin: 8px 8px 8px 0;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      position: relative;
      overflow: hidden;
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .btn-primary {
      background: var(--primary-color);
      color: white;
      border: 2px solid var(--primary-color);
    }

    .btn-primary:hover:not(:disabled) {
      background: var(--primary-hover);
      border-color: var(--primary-hover);
      transform: translateY(-1px);
    }

    .btn-secondary {
      background: var(--secondary-bg);
      color: white;
      border: 2px solid var(--secondary-bg);
    }

    .btn-secondary:hover:not(:disabled) {
      background: var(--secondary-hover);
      border-color: var(--secondary-hover);
    }

    .btn-success {
      background: var(--success-color);
      color: white;
      border: 2px solid var(--success-color);
    }

    .btn-success:hover:not(:disabled) {
      background: var(--success-hover);
      border-color: var(--success-hover);
    }

    .btn-claude {
      background: linear-gradient(135deg, var(--claude-color) 0%, var(--claude-hover) 100%);
      color: white;
      border: 2px solid var(--claude-color);
      position: relative;
    }

    .btn-claude::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }

    .btn-claude:hover:not(:disabled)::before {
      left: 100%;
    }

    .btn-claude:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
    }

    .new-badge {
      position: absolute;
      top: -8px;
      right: -8px;
      background: #ff4444;
      color: white;
      font-size: 10px;
      font-weight: bold;
      padding: 2px 6px;
      border-radius: 10px;
      text-transform: uppercase;
    }

    .status {
      margin: 20px 0;
      padding: 12px;
      border-radius: 8px;
      font-weight: 600;
    }

    .status.success {
      background: #d4edda;
      color: var(--success-color);
      border: 1px solid #c3e6cb;
    }

    .status.error {
      background: #f8d7da;
      color: var(--error-color);
      border: 1px solid #f5c6cb;
    }

    .status.info {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
    }

    .transcript-area {
      width: 100%;
      min-height: 200px;
      margin: 16px 0;
      padding: 16px;
      background: #fafafa;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      resize: vertical;
      font-family: monospace;
      font-size: 14px;
      line-height: 1.6;
      color: var(--text-color);
    }

    [data-theme="dark"] .transcript-area {
      background: #333333;
      color: #ffffff;
    }

    .history-list {
      margin: 20px 0;
      padding: 0;
      list-style: none;
    }

    .history-item {
      margin-bottom: 16px;
      padding: 16px;
      background: #f8f9fa;
      border-radius: 8px;
      border: 1px solid var(--border-color);
    }

    [data-theme="dark"] .history-item {
      background: #333333;
    }

    .history-meta {
      font-size: 14px;
      color: #666;
      margin-bottom: 8px;
    }

    [data-theme="dark"] .history-meta {
      color: #aaa;
    }

    .debug-info {
      background: #fff3cd;
      color: #856404;
      padding: 16px;
      margin: 16px 0;
      border-radius: 8px;
      border: 1px solid #ffeaa7;
      font-family: monospace;
      font-size: 14px;
      line-height: 1.4;
    }

    [data-theme="dark"] .debug-info {
      background: #3d3d00;
      color: #ffff99;
      border-color: #666600;
    }

    .loading {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid var(--primary-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .hidden {
      display: none !important;
    }

    .fade-in {
      animation: fadeIn 0.3s ease-in;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .file-info {
      margin-top: 8px;
      padding: 8px;
      background: #e3f2fd;
      border-radius: 4px;
      font-size: 14px;
      color: #1565c0;
    }

    [data-theme="dark"] .file-info {
      background: #1a3a52;
      color: #64b5f6;
    }

    .file-info.error {
      background: #ffebee;
      color: #c62828;
    }

    [data-theme="dark"] .file-info.error {
      background: #4d1f1f;
      color: #ef5350;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: #f0f0f0;
      border-radius: 4px;
      overflow: hidden;
      margin: 16px 0;
    }

    [data-theme="dark"] .progress-bar {
      background: #333333;
    }

    .progress-fill {
      height: 100%;
      background: var(--primary-color);
      transition: width 0.3s ease;
      width: 0%;
    }

    /* –ù–æ–≤—ã–µ —Å—Ç–∏–ª–∏ –¥–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ */
    .async-progress-container {
      background: var(--card-background);
      border: 2px solid var(--claude-color);
      border-radius: 12px;
      padding: 20px;
      margin: 20px 0;
      text-align: center;
    }

    .async-progress-header {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-bottom: 15px;
    }

    .async-progress-header h3 {
      margin: 0;
      color: var(--claude-color);
    }

    .progress-status {
      font-size: 18px;
      margin: 10px 0;
      color: var(--text-color);
    }

    .progress-percentage {
      font-size: 24px;
      font-weight: bold;
      color: var(--claude-color);
      margin: 10px 0;
    }

    .progress-bar-async {
      width: 100%;
      height: 12px;
      background: #f0f0f0;
      border-radius: 6px;
      overflow: hidden;
      margin: 15px 0;
      position: relative;
    }

    [data-theme="dark"] .progress-bar-async {
      background: #333333;
    }

    .progress-fill-async {
      height: 100%;
      background: linear-gradient(90deg, var(--claude-color), var(--claude-hover));
      transition: width 0.5s ease;
      width: 0%;
      position: relative;
    }

    .progress-fill-async::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .estimated-time {
      font-size: 14px;
      color: #666;
      margin-top: 10px;
    }

    [data-theme="dark"] .estimated-time {
      color: #aaa;
    }

    .status-steps {
      display: flex;
      justify-content: space-between;
      margin: 20px 0;
      font-size: 12px;
    }

    .status-step {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 1;
      position: relative;
    }

    .status-step::after {
      content: '';
      position: absolute;
      top: 15px;
      left: 50%;
      width: 100%;
      height: 2px;
      background: #ddd;
      z-index: 0;
    }

    .status-step:last-child::after {
      display: none;
    }

    .status-step-icon {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: #ddd;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      margin-bottom: 5px;
      position: relative;
      z-index: 1;
      transition: all 0.3s ease;
    }

    .status-step.active .status-step-icon {
      background: var(--claude-color);
      color: white;
    }

    .status-step.completed .status-step-icon {
      background: var(--success-color);
      color: white;
    }

    /* –°—Ç–∏–ª–∏ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ Claude */
    .analysis-frame-container {
      background: white;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      max-height: 70vh;
      overflow-y: auto;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    }

    .analysis-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      border-bottom: 2px solid var(--border-color);
      padding-bottom: 15px;
    }

    .analysis-actions {
      margin-top: 15px;
      text-align: center;
      gap: 10px;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
    }

    .analysis-container-wrapper {
      background: var(--card-background);
      padding: 20px;
      border-radius: 12px;
      margin: 20px 0;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    }

    @media (max-width: 600px) {
      body {
        padding: 10px;
      }

      .container {
        padding: 16px;
      }

      .btn {
        width: 100%;
        margin-bottom: 8px;
        justify-content: center;
      }

      .analysis-header {
        flex-direction: column;
        gap: 10px;
        text-align: center;
      }

      .analysis-actions {
        flex-direction: column;
      }

      .analysis-actions .btn {
        width: 100%;
        margin: 5px 0;
      }

      .status-steps {
        flex-direction: column;
        gap: 10px;
      }

      .status-step::after {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div id="debugInfo" class="debug-info hidden"></div>

  <div class="container">
    <form id="uploadForm">
      <h2>üé§ Audio Transcription</h2>

      <div class="form-group">
        <label for="audioFile">Audio File:</label>
        <input type="file" id="audioFile" name="file" accept="audio/*,audio/mp4,audio/mpeg,audio/wav,audio/x-m4a,audio/aac,.m4a,.mp3,.wav,.aac,.mp4,.mov,.caf" required />
        <div id="fileInfo" class="file-info hidden"></div>
      </div>

      <div class="form-group">
        <label for="prompt">Prompt (optional):</label>
        <input type="text" id="prompt" name="prompt" placeholder="Provide context to improve accuracy..." />
      </div>

      <div class="form-group">
        <label>Options:</label>
        <div class="checkbox-group">
          <input type="checkbox" id="translate" name="translate" />
          <label for="translate">Translate to English</label>
        </div>
      </div>

      <div class="form-group">
        <label for="language">Language:</label>
        <select id="language" name="language" required>
          <option value="english" selected>English</option>
          <option value="russian">Russian</option>
          <option value="armenian">Armenian</option>
        </select>
      </div>

      <div class="form-group">
        <label for="speakerMode">Number of Speakers:</label>
        <select id="speakerMode" name="speaker_mode" required>
          <option value="auto" selected>Detect automatically</option>
          <option value="manual">Specify manually</option>
        </select>
      </div>

      <div class="form-group hidden" id="manualSpeakersGroup">
        <label for="numSpeakers">Number of participants:</label>
        <input type="number" id="numSpeakers" name="num_speakers" value="2" min="1" max="20" />
      </div>

      <div class="form-group">
        <label for="outputFormat">Output Format:</label>
        <select id="outputFormat" name="output_format">
          <option value="markdown" selected>Markdown</option>
          <option value="text">Plain Text</option>
          <option value="srt">SRT Subtitles</option>
        </select>
      </div>

      <input type="hidden" name="initData" id="initData" />

      <div class="progress-bar hidden" id="progressBar">
        <div class="progress-fill" id="progressFill"></div>
      </div>

      <button type="submit" class="btn btn-primary" id="submitBtn">
        <span id="submitText">Upload & Transcribe</span>
      </button>

      <button type="button" id="analyzeBtn" class="btn btn-claude">
        üß† AI Analysis with Claude
        <span class="new-badge">New</span>
      </button>

      <button type="button" id="showHistoryBtn" class="btn btn-secondary">
        üìã My Transcriptions
      </button>

      <button type="button" id="debugBtn" class="btn btn-secondary">
        üîß Debug Info
      </button>

      <div class="status hidden" id="status"></div>
    </form>

    <div id="resultContainer" class="container hidden fade-in"></div>
    <div id="historyContainer" class="container hidden fade-in"></div>
    <div id="analysisContainer" class="hidden fade-in"></div>
    <div id="asyncAnalysisContainer" class="hidden fade-in"></div>
  </div>

  <script>
    // Constants
    const MAX_FILE_SIZE = 100 * 1024 * 1024; // 100MB
    const SUPPORTED_TYPES = ['audio/', 'video/'];
    const SUPPORTED_EXTENSIONS = ['.m4a', '.mp3', '.wav', '.aac', '.mp4', '.mov', '.caf'];
    const SYNC_ANALYSIS_LIMIT = 10 * 1024 * 1024; // 10MB

    // Global variables
    let tg = null;
    let currentView = 'upload';
    let asyncTaskId = null;
    let pollingInterval = null;

    // Utility functions
    const $ = (id) => document.getElementById(id);
    const show = (el) => el.classList.remove('hidden');
    const hide = (el) => el.classList.add('hidden');
    const formatFileSize = (bytes) => {
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      if (bytes === 0) return '0 Bytes';
      const i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
      return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
    };

    // Modern clipboard API with fallback
    async function copyToClipboard(text) {
      if (navigator.clipboard && window.isSecureContext) {
        try {
          await navigator.clipboard.writeText(text);
          return true;
        } catch (err) {
          console.warn('Clipboard API failed:', err);
        }
      }

      // Fallback to deprecated method
      try {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();
        const success = document.execCommand('copy');
        document.body.removeChild(textarea);
        return success;
      } catch (err) {
        console.error('Copy fallback failed:', err);
        return false;
      }
    }

    // Status management
    function showStatus(message, type = 'info', duration = 0) {
      const status = $('status');
      status.className = `status ${type}`;
      status.innerHTML = message;
      show(status);

      if (duration > 0) {
        setTimeout(() => hide(status), duration);
      }
    }

    function showLoading(message = 'Processing...') {
      showStatus(`<div class="loading"><div class="spinner"></div>${message}</div>`, 'info');
    }

    // File validation
    function validateFile(file) {
      if (!file) {
        throw new Error('No file selected');
      }

      if (file.size === 0) {
        throw new Error('File is empty');
      }

      if (file.size > MAX_FILE_SIZE) {
        throw new Error(`File too large (${formatFileSize(file.size)}). Maximum size is ${formatFileSize(MAX_FILE_SIZE)}`);
      }

      const isSupported = SUPPORTED_TYPES.some(type => file.type.startsWith(type)) ||
                         SUPPORTED_EXTENSIONS.some(ext => file.name.toLowerCase().endsWith(ext));

      if (!isSupported) {
        throw new Error(`Unsupported file type: ${file.type || 'unknown'}. Please upload an audio or video file.`);
      }

      return true;
    }

    // API calls with better error handling - –ò–°–ü–†–ê–í–õ–ï–ù–û: —É–≤–µ–ª–∏—á–µ–Ω —Ç–∞–π–º–∞—É—Ç
    async function apiCall(url, options = {}) {
      const controller = new AbortController();

      // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π —Ç–∞–π–º–∞—É—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ –∑–∞–ø—Ä–æ—Å–∞
      let timeoutDuration = 60000; // 60s –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é

      if (url.includes('/upload') || url.includes('/analyze')) {
        timeoutDuration = 300000; // 5 –º–∏–Ω—É—Ç –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –∏ –∞–Ω–∞–ª–∏–∑–∞
      } else if (url.includes('/auth') || url.includes('/history')) {
        timeoutDuration = 10000; // 10s –¥–ª—è –±—ã—Å—Ç—Ä—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
      }

      const timeoutId = setTimeout(() => controller.abort(), timeoutDuration);

      try {
        const response = await fetch(url, {
          ...options,
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }

        return response;
      } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
          const minutes = Math.floor(timeoutDuration / 60000);
          throw new Error(`Request timeout (${minutes} min) - please try with a smaller file or use async analysis`);
        }
        throw error;
      }
    }

    // Authentication
    async function authenticate() {
      const initData = $('initData').value;
      if (!initData) {
        throw new Error('No authorization data available. Please restart from Telegram.');
      }

      const response = await apiCall('/auth', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({ initData })
      });

      const result = await response.json();
      return result.access_token;
    }

    // View management
    function showView(viewName) {
      const views = ['uploadForm', 'resultContainer', 'historyContainer', 'analysisContainer', 'asyncAnalysisContainer'];
      views.forEach(view => {
        const el = $(view);
        if (view === viewName || (viewName === 'upload' && view === 'uploadForm')) {
          show(el);
        } else {
          hide(el);
        }
      });
      currentView = viewName;
    }

    function showResult(transcript, filename, outputFormat, message) {
      const container = $('resultContainer');
      container.innerHTML = `
        <h2>‚úÖ Transcription Complete</h2>
        <div class="status success">${message || 'Your audio has been successfully transcribed.'}</div>
        <div class="form-group">
          <label>File: ${filename} (${outputFormat})</label>
          <textarea class="transcript-area" readonly id="transcriptText">${transcript}</textarea>
        </div>
        <button type="button" class="btn btn-success" id="copyBtn">
          üìã Copy Transcript
        </button>
        <button type="button" class="btn btn-secondary" onclick="showView('upload')">
          ‚¨ÖÔ∏è New Transcription
        </button>
      `;

      $('copyBtn').onclick = async () => {
        const success = await copyToClipboard(transcript);
        const btn = $('copyBtn');
        if (success) {
          btn.innerHTML = '‚úÖ Copied!';
          btn.classList.add('btn-success');
          setTimeout(() => {
            btn.innerHTML = 'üìã Copy Transcript';
            btn.classList.remove('btn-success');
          }, 2000);
        } else {
          showStatus('Copy failed. Please select the text manually.', 'error', 3000);
        }
      };

      showView('resultContainer');
    }

    // Async analysis progress display
    function showAsyncProgress(taskData) {
      const container = $('asyncAnalysisContainer');

      container.innerHTML = `
        <div class="async-progress-container">
          <div class="async-progress-header">
            <div class="spinner"></div>
            <h3>üß† Claude is analyzing your audio</h3>
          </div>

          <div class="progress-status" id="progressStatus">Starting analysis...</div>
          <div class="progress-percentage" id="progressPercentage">0%</div>

          <div class="progress-bar-async">
            <div class="progress-fill-async" id="progressFillAsync"></div>
          </div>

          <div class="status-steps">
            <div class="status-step" id="step-pending">
              <div class="status-step-icon">‚è≥</div>
              <div>Queued</div>
            </div>
            <div class="status-step" id="step-transcribing">
              <div class="status-step-icon">üé§</div>
              <div>Transcribing</div>
            </div>
            <div class="status-step" id="step-analyzing">
              <div class="status-step-icon">üß†</div>
              <div>Analyzing</div>
            </div>
            <div class="status-step" id="step-completed">
              <div class="status-step-icon">‚úÖ</div>
              <div>Complete</div>
            </div>
          </div>

          <div class="estimated-time" id="estimatedTime">
            ${taskData.estimated_time ? `Estimated time: ${taskData.estimated_time}` : ''}
          </div>

          <div style="margin-top: 20px;">
            <button type="button" class="btn btn-secondary" onclick="cancelAsyncAnalysis()">
              ‚ùå Cancel Analysis
            </button>
            <button type="button" class="btn btn-secondary" onclick="showView('upload')">
              ‚¨ÖÔ∏è Start New Task
            </button>
          </div>
        </div>
      `;

      showView('asyncAnalysisContainer');
    }

    // Update async progress
    function updateAsyncProgress(status, progress = 0) {
      const progressStatus = $('progressStatus');
      const progressPercentage = $('progressPercentage');
      const progressFillAsync = $('progressFillAsync');

      if (progressStatus) progressStatus.textContent = getStatusMessage(status);
      if (progressPercentage) progressPercentage.textContent = `${progress}%`;
      if (progressFillAsync) progressFillAsync.style.width = `${progress}%`;

      // Update status steps
      const steps = ['pending', 'transcribing', 'analyzing', 'completed'];
      steps.forEach(step => {
        const stepEl = $(`step-${step}`);
        if (stepEl) {
          stepEl.classList.remove('active', 'completed');

          if (status === step) {
            stepEl.classList.add('active');
          } else if (steps.indexOf(status) > steps.indexOf(step)) {
            stepEl.classList.add('completed');
          }
        }
      });
    }

    function getStatusMessage(status) {
      const messages = {
        'pending': 'Waiting in queue...',
        'transcribing': 'Converting speech to text...',
        'analyzing': 'Claude is analyzing the conversation...',
        'completed': 'Analysis complete!',
        'failed': 'Analysis failed'
      };
      return messages[status] || 'Processing...';
    }

    // Poll async task status
    async function pollAsyncTask(taskId) {
      try {
        const token = await authenticate();
        const response = await apiCall(`/task/${taskId}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        const taskData = await response.json();
        updateAsyncProgress(taskData.status, taskData.progress);

        if (taskData.status === 'completed') {
          // Stop polling
          if (pollingInterval) {
            clearInterval(pollingInterval);
            pollingInterval = null;
          }

          // Get the result
          setTimeout(async () => {
            try {
              const resultResponse = await apiCall(`/task/${taskId}/result`, {
                headers: { 'Authorization': `Bearer ${token}` }
              });
              const htmlContent = await resultResponse.text();
              showAnalysis(htmlContent, taskData.filename);
            } catch (error) {
              showStatus(`‚ùå Failed to load result: ${error.message}`, 'error');
            }
          }, 1000);

        } else if (taskData.status === 'failed') {
          // Stop polling
          if (pollingInterval) {
            clearInterval(pollingInterval);
            pollingInterval = null;
          }

          showStatus(`‚ùå Analysis failed: ${taskData.error || 'Unknown error'}`, 'error');

          // Show retry option
          setTimeout(() => {
            const container = $('asyncAnalysisContainer');
            container.innerHTML += `
              <div style="text-align: center; margin-top: 20px;">
                <button type="button" class="btn btn-claude" onclick="retryLastAnalysis()">
                  üîÑ Retry Analysis
                </button>
              </div>
            `;
          }, 2000);
        }

      } catch (error) {
        console.error('Polling error:', error);
        showStatus(`‚ùå Connection error: ${error.message}`, 'error');
      }
    }

    // Start async analysis polling
    function startAsyncPolling(taskId) {
      asyncTaskId = taskId;

      // Poll every 3 seconds
      pollingInterval = setInterval(() => {
        pollAsyncTask(taskId);
      }, 3000);

      // Initial poll
      pollAsyncTask(taskId);
    }

    // Cancel async analysis
    function cancelAsyncAnalysis() {
      if (pollingInterval) {
        clearInterval(pollingInterval);
        pollingInterval = null;
      }
      asyncTaskId = null;
      showView('upload');
      showStatus('Analysis cancelled', 'info', 3000);
    }

    // Retry last analysis (store file data for retry)
    let lastAnalysisFile = null;

    function retryLastAnalysis() {
      if (lastAnalysisFile) {
        performClaudeAnalysis(lastAnalysisFile);
      } else {
        showStatus('‚ùå No previous analysis to retry', 'error', 3000);
      }
    }

    // Improved Claude analysis display
    function showAnalysis(htmlContent, filename) {
      const container = $('analysisContainer');

      container.innerHTML = `
        <div class="analysis-container-wrapper">
          <div class="analysis-header">
            <div>
              <h2 style="margin: 0; color: var(--text-color);">üß† AI Analysis Report</h2>
              <p style="margin: 5px 0 0 0; color: var(--text-color); opacity: 0.7;">Claude analyzed: ${filename}</p>
            </div>
            <button type="button" class="btn btn-secondary" onclick="showView('upload')" style="margin: 0;">
              ‚¨ÖÔ∏è Back
            </button>
          </div>

          <div class="analysis-frame-container">
            <iframe
              id="analysisFrame"
              style="width: 100%; min-height: 500px; border: none; border-radius: 8px;"
              sandbox="allow-same-origin allow-scripts"
              srcdoc=""></iframe>
          </div>

          <div class="analysis-actions">
            <button type="button" class="btn btn-primary" onclick="openAnalysisFullscreen()">
              üîç Open Fullscreen
            </button>
            <button type="button" class="btn btn-secondary" onclick="downloadAnalysis('${filename}')">
              üíæ Download Report
            </button>
            <button type="button" class="btn btn-secondary" onclick="copyAnalysisHTML()">
              üìã Copy HTML
            </button>
            <button type="button" class="btn btn-secondary" onclick="shareAnalysis()">
              üì§ Share Analysis
            </button>
          </div>
        </div>
      `;

      // –ë–µ–∑–æ–ø–∞—Å–Ω–æ –≤—Å—Ç–∞–≤–ª—è–µ–º HTML –≤ iframe
      const iframe = document.getElementById('analysisFrame');
      iframe.srcdoc = htmlContent;

      // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ–¥—Å—Ç—Ä–∞–∏–≤–∞–µ–º –≤—ã—Å–æ—Ç—É iframe
      iframe.onload = function() {
        try {
          const iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
          if (iframeDocument && iframeDocument.body) {
            const height = iframeDocument.body.scrollHeight;
            iframe.style.height = Math.min(height + 50, window.innerHeight * 0.7) + 'px';
          }
        } catch (e) {
          // –ï—Å–ª–∏ –Ω–µ —É–¥–∞–µ—Ç—Å—è –ø–æ–ª—É—á–∏—Ç—å –≤—ã—Å–æ—Ç—É, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—É—é
          iframe.style.height = '500px';
        }
      };

      showView('analysisContainer');
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –∞–Ω–∞–ª–∏–∑–∞ –≤ –ø–æ–ª–Ω–æ–º —ç–∫—Ä–∞–Ω–µ
    function openAnalysisFullscreen() {
      const iframe = document.getElementById('analysisFrame');
      if (iframe && iframe.srcdoc) {
        const newWindow = window.open('', '_blank');
        if (newWindow) {
          newWindow.document.write(iframe.srcdoc);
          newWindow.document.close();
        } else {
          showStatus('‚ùå Popup blocked. Please allow popups for this site.', 'error', 3000);
        }
      }
    }

    // –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –æ—Ç—á–µ—Ç–∞ —Å fallback
    function downloadAnalysis(filename) {
      const iframe = document.getElementById('analysisFrame');
      if (iframe && iframe.srcdoc) {
        try {
          // –ú–µ—Ç–æ–¥ 1: –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ —á–µ—Ä–µ–∑ Blob
          const blob = new Blob([iframe.srcdoc], { type: 'text/html; charset=utf-8' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `${filename.replace(/\.[^/.]+$/, "")}_analysis.html`;
          a.style.display = 'none';

          // –î–æ–±–∞–≤–ª—è–µ–º –≤ DOM, –∫–ª–∏–∫–∞–µ–º –∏ —É–¥–∞–ª—è–µ–º
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);

          // –û—á–∏—â–∞–µ–º URL —á–µ—Ä–µ–∑ –Ω–µ–±–æ–ª—å—à—É—é –∑–∞–¥–µ—Ä–∂–∫—É
          setTimeout(() => URL.revokeObjectURL(url), 100);

          showStatus('‚úÖ Report downloaded successfully!', 'success', 3000);
        } catch (error) {
          console.error('Download error:', error);

          // –ú–µ—Ç–æ–¥ 2: Fallback - –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ HTML –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞
          copyToClipboard(iframe.srcdoc).then(success => {
            if (success) {
              showStatus('üìã HTML copied to clipboard! Create .html file and paste content to save.', 'info', 5000);
            } else {
              // –ú–µ—Ç–æ–¥ 3: –ü–æ—Å–ª–µ–¥–Ω–∏–π fallback - –æ—Ç–∫—Ä—ã—Ç–∏–µ –≤ –Ω–æ–≤–æ–º –æ–∫–Ω–µ
              showStatus('‚ùå Download failed. Opening in fullscreen - use Ctrl+S to save manually.', 'error', 5000);
              setTimeout(() => openAnalysisFullscreen(), 1000);
            }
          });
        }
      } else {
        showStatus('‚ùå No analysis report found to download.', 'error', 3000);
      }
    }

    // –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è HTML
    function copyAnalysisHTML() {
      const iframe = document.getElementById('analysisFrame');
      if (iframe && iframe.srcdoc) {
        copyToClipboard(iframe.srcdoc).then(success => {
          if (success) {
            showStatus('üìã HTML copied to clipboard! Create .html file and paste to save.', 'success', 5000);
          } else {
            showStatus('‚ùå Copy failed. Try using the Download button.', 'error', 3000);
          }
        });
      } else {
        showStatus('‚ùå No analysis report found to copy.', 'error', 3000);
      }
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞—Å—à–∞—Ä–∏–≤–∞–Ω–∏—è –∞–Ω–∞–ª–∏–∑–∞
    function shareAnalysis() {
      if (navigator.share) {
        navigator.share({
          title: 'Speech Analysis Report',
          text: 'Check out this AI-powered speech analysis report generated by Claude.',
          url: window.location.href
        }).catch(err => console.log('Error sharing:', err));
      } else {
        // Fallback to copying URL
        copyToClipboard(window.location.href).then(success => {
          if (success) {
            showStatus('‚úÖ Link copied to clipboard!', 'success', 3000);
          } else {
            showStatus('‚ùå Sharing not supported on this device.', 'error', 3000);
          }
        });
      }
    }

    async function showHistory() {
      showLoading('Loading your transcriptions...');

      try {
        const token = await authenticate();
        const response = await apiCall('/history', {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        const history = await response.json();
        const container = $('historyContainer');

        if (!Array.isArray(history) || history.length === 0) {
          container.innerHTML = `
            <h2>üìã My Transcriptions</h2>
            <div class="status info">No transcriptions found. Upload your first audio file!</div>
            <button type="button" class="btn btn-primary" onclick="showView('upload')">
              üé§ Upload Audio
            </button>
          `;
        } else {
          let historyHTML = '<h2>üìã My Transcriptions</h2><ul class="history-list">';

          history.forEach((item, index) => {
            const date = new Date(item.created_at).toLocaleString();
            const isAnalysis = item.output_format === 'html_analysis';
            const icon = isAnalysis ? 'üß†' : 'üìÑ';
            const type = isAnalysis ? 'AI Analysis' : 'Transcription';

            historyHTML += `
              <li class="history-item">
                <div class="history-meta">${date} ‚Ä¢ ${item.filename} ‚Ä¢ ${type}</div>
                <button type="button" class="btn btn-secondary" onclick="showHistoryItem(${index})">
                  ${icon} View ${type}
                </button>
              </li>
            `;
          });

          historyHTML += `
            </ul>
            <button type="button" class="btn btn-secondary" onclick="showView('upload')">
              ‚¨ÖÔ∏è Back to Upload
            </button>
          `;

          container.innerHTML = historyHTML;

          // Store history for access
          window.historyData = history;
        }

        showView('historyContainer');
        hide($('status'));

      } catch (error) {
        showStatus(`‚ùå Failed to load history: ${error.message}`, 'error');
      }
    }

    function showHistoryItem(index) {
      const item = window.historyData[index];
      const date = new Date(item.created_at).toLocaleString();

      if (item.output_format === 'html_analysis') {
        showAnalysis(item.transcript, item.filename);
      } else {
        showResult(item.transcript, item.filename, item.output_format, `Transcription from ${date}`);
      }
    }

    // Improved Claude Analysis function with async support
    async function performClaudeAnalysis(fileOverride = null) {
      const analyzeBtn = $('analyzeBtn');
      const originalText = analyzeBtn.innerHTML;

      try {
        // Validate form
        const fileInput = $('audioFile');
        const file = fileOverride || fileInput.files[0];
        validateFile(file);

        // Store file for potential retry
        lastAnalysisFile = file;

        // Disable button and show loading
        analyzeBtn.disabled = true;
        analyzeBtn.innerHTML = '<div class="loading"><div class="spinner"></div>Analyzing with Claude...</div>';

        // Authenticate
        const token = await authenticate();

        // Prepare form data
        const formData = new FormData();
        formData.append('file', file);
        formData.append('speaker_labels', 'true');
        formData.append('language', $('language').value);
        formData.append('prompt', $('prompt').value || '');
        formData.append('translate', $('translate').checked);

        // Handle speaker parameters
        const speakerMode = $('speakerMode').value;
        formData.append('min_speakers', '1');

        if (speakerMode === 'manual') {
          const numSpeakers = $('numSpeakers').value || '2';
          formData.append('max_speakers', numSpeakers);
        } else {
          formData.append('max_speakers', '8');
        }

        // Check file size and choose endpoint
        const fileSizeMB = file.size / (1024 * 1024);
        const isLargeFile = fileSizeMB > 10;

        if (isLargeFile) {
          // Use async endpoint for large files
          showLoading(`üß† Starting analysis for large file (${fileSizeMB.toFixed(1)}MB)...`);

          const response = await apiCall('/analyze-async', {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${token}` },
            body: formData
          });

          const result = await response.json();

          // Show async progress
          showAsyncProgress(result);

          // Start polling
          startAsyncPolling(result.task_id);

          hide($('status'));

        } else {
          // Use sync endpoint for small files
          showLoading(`üß† Claude is analyzing your audio (${fileSizeMB.toFixed(1)}MB)... This may take up to 5 minutes.`);

          const response = await apiCall('/analyze', {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${token}` },
            body: formData
          });

          // Get HTML response
          const htmlContent = await response.text();

          // Show analysis result
          showAnalysis(htmlContent, file.name);
          hide($('status'));
        }

      } catch (error) {
        showStatus(`‚ùå Analysis failed: ${error.message}`, 'error');
      } finally {
        // Reset button
        analyzeBtn.disabled = false;
        analyzeBtn.innerHTML = originalText;
      }
    }

    // File input handler
    $('audioFile').onchange = function(e) {
      const file = e.target.files[0];
      const fileInfo = $('fileInfo');

      if (!file) {
        hide(fileInfo);
        return;
      }

      try {
        validateFile(file);
        const fileSizeMB = file.size / (1024 * 1024);
        const analysisType = fileSizeMB > 10 ? 'Async Analysis (Large File)' : 'Quick Analysis (up to 5 min)';

        fileInfo.innerHTML = `
          üìÅ ${file.name}<br>
          üìä ${formatFileSize(file.size)}<br>
          üéµ ${file.type || 'Unknown type'}<br>
          üß† ${analysisType}
        `;
        fileInfo.className = 'file-info';
        show(fileInfo);
      } catch (error) {
        fileInfo.innerHTML = `‚ùå ${error.message}`;
        fileInfo.className = 'file-info error';
        show(fileInfo);
      }
    };

    // Debug functionality
    $('debugBtn').onclick = () => {
      const debugInfo = $('debugInfo');
      const isVisible = !debugInfo.classList.contains('hidden');

      if (isVisible) {
        hide(debugInfo);
        $('debugBtn').innerHTML = 'üîß Debug Info';
      } else {
        const initData = $('initData').value;
        debugInfo.innerHTML = `
          <strong>Debug Information:</strong><br>
          <strong>initData length:</strong> ${initData.length}<br>
          <strong>initData:</strong> ${initData.substring(0, 100)}${initData.length > 100 ? '...' : ''}<br>
          <strong>User ID:</strong> ${tg?.initDataUnsafe?.user?.id || 'unknown'}<br>
          <strong>Username:</strong> ${tg?.initDataUnsafe?.user?.username || 'unknown'}<br>
          <strong>WebApp version:</strong> ${tg?.version || 'unknown'}<br>
          <strong>Platform:</strong> ${tg?.platform || 'unknown'}<br>
          <strong>Color scheme:</strong> ${tg?.colorScheme || 'unknown'}<br>
          <strong>Current task:</strong> ${asyncTaskId || 'none'}<br>
          <strong>Polling active:</strong> ${pollingInterval ? 'yes' : 'no'}
        `;
        show(debugInfo);
        $('debugBtn').innerHTML = 'üîß Hide Debug';
      }
    };

    // Speaker mode handler
    $('speakerMode').onchange = function(e) {
      const manualGroup = $('manualSpeakersGroup');
      if (e.target.value === 'manual') {
        show(manualGroup);
      } else {
        hide(manualGroup);
      }
    };

    // Event handlers
    $('showHistoryBtn').onclick = showHistory;
    $('analyzeBtn').onclick = () => performClaudeAnalysis();

    // Form submission
    $('uploadForm').onsubmit = async (e) => {
      e.preventDefault();

      const submitBtn = $('submitBtn');
      const submitText = $('submitText');
      const progressBar = $('progressBar');
      const progressFill = $('progressFill');

      try {
        // Validate form
        const fileInput = $('audioFile');
        const file = fileInput.files[0];
        validateFile(file);

        // Disable form
        submitBtn.disabled = true;
        show(progressBar);

        // Step 1: Authentication
        submitText.textContent = 'Authenticating...';
        progressFill.style.width = '20%';

        const token = await authenticate();

        // Step 2: Prepare upload
        submitText.textContent = 'Preparing upload...';
        progressFill.style.width = '40%';

        const formData = new FormData(e.target);
        formData.delete('initData');
        formData.set('speaker_labels', 'true');

        // Handle speaker parameters
        const speakerMode = formData.get('speaker_mode');
        formData.set('min_speakers', '1');

        if (speakerMode === 'manual') {
          const numSpeakers = formData.get('num_speakers') || '2';
          formData.set('max_speakers', numSpeakers);
        } else {
          formData.set('max_speakers', '8');
        }

        // Remove our custom fields
        formData.delete('speaker_mode');
        formData.delete('num_speakers');

        // Step 3: Upload
        submitText.textContent = 'Uploading & transcribing...';
        progressFill.style.width = '60%';

        const response = await apiCall('/upload', {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}` },
          body: formData
        });

        progressFill.style.width = '100%';

        const result = await response.json();

        if (result.transcript) {
          showResult(result.transcript, result.filename, result.output_format, result.message);
        } else {
          showStatus(`‚úÖ ${result.message || 'Upload successful!'}`, 'success');
        }

      } catch (error) {
        showStatus(`‚ùå ${error.message}`, 'error');
      } finally {
        // Reset form state
        submitBtn.disabled = false;
        submitText.textContent = 'Upload & Transcribe';
        hide(progressBar);
        progressFill.style.width = '0%';
      }
    };

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (pollingInterval) {
        clearInterval(pollingInterval);
      }
    });

    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      console.log('Initializing Telegram WebApp...');

      if (!window.Telegram?.WebApp) {
        showStatus('‚ùå Telegram WebApp not available. Please open from Telegram bot.', 'error');
        return;
      }

      tg = window.Telegram.WebApp;
      tg.ready();
      tg.expand();

      // Apply Telegram theme
      if (tg.colorScheme === 'dark') {
        document.documentElement.setAttribute('data-theme', 'dark');
        document.documentElement.style.setProperty('--background-color', tg.themeParams.bg_color || '#1a1a1a');
        document.documentElement.style.setProperty('--card-background', tg.themeParams.secondary_bg_color || '#2a2a2a');
        document.documentElement.style.setProperty('--text-color', tg.themeParams.text_color || '#ffffff');
      }

      // Set initData
      $('initData').value = tg.initData || '';

      // Show ready status
      if (tg.initData) {
        showStatus('‚úÖ Ready to transcribe your audio files!', 'success', 3000);
      } else {
        showStatus('‚ö†Ô∏è No Telegram data found. Please open from Telegram bot.', 'error');
      }

      console.log('WebApp initialized successfully');
    });
  </script>
</body>
</html>