<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Upload Audio</title>
  <style>
    body { font-family: sans-serif; padding: 20px; background: #f6f6f6; }
    form { background: white; padding: 20px; border-radius: 8px; max-width: 600px; margin: auto; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
    label { display: block; margin-top: 15px; }
    input[type="text"], input[type="file"], select, input[type="number"] { width: 100%; padding: 8px; margin-top: 5px; }
    button { padding: 10px 20px; margin-top: 20px; background: #0088cc; color: white; border: none; border-radius: 4px; cursor: pointer; }
    button:hover { background: #0077b3; }
    .status { margin-top: 20px; }
  </style>
</head>
<body>
  <form id="uploadForm">
    <h2>üé§ Upload your audio</h2>
    <label>Audio file:
      <input type="file" name="file" accept="audio/*" required />
    </label>
    <label>Prompt:
      <input type="text" name="prompt" />
    </label>
    <label>Translate to English:
      <input type="checkbox" name="translate" />
    </label>
    <label>Language:
      <select name="language" required>
        <option value="english" selected>english</option>
        <!-- ... –æ—Å—Ç–∞–ª—å–Ω—ã–µ —è–∑—ã–∫–∏ ... -->
        <option value="russian">russian</option>
        <!-- (–≤—Å–µ —è–∑—ã–∫–∏ –∫–∞–∫ —É —Ç–µ–±—è, –∑–¥–µ—Å—å —É—Ä–µ–∑–∞–Ω–æ –¥–ª—è –∫—Ä–∞—Ç–∫–æ—Å—Ç–∏) -->
      </select>
    </label>
    <label>Timestamp Granularities:
      <select name="timestamp_granularities">
        <option value="segment">segment</option>
        <option value="word">word</option>
      </select>
    </label>
    <label>Min Speakers:
      <input type="number" name="min_speakers" value="1" min="1" />
    </label>
    <label>Max Speakers:
      <input type="number" name="max_speakers" value="8" min="1" />
    </label>
    <label>Output Format:
      <select name="output_format">
        <option value="markdown" selected>markdown</option>
        <option value="text">text</option>
        <option value="srt">srt</option>
      </select>
    </label>
    <input type="hidden" name="initData" id="initData" />
    <button type="submit">Upload</button>
    <div class="status" id="status"></div>
  </form>
  <script>
    window.addEventListener("DOMContentLoaded", () => {
      const tg = window.Telegram?.WebApp;
      const initData = tg?.initData || "";
      console.log("initData = ", initData); // <--- —ç—Ç–∞ —Å—Ç—Ä–æ–∫–∞ –ø–æ–∫–∞–∂–µ—Ç, —á—Ç–æ —Ä–µ–∞–ª—å–Ω–æ –ø–µ—Ä–µ–¥–∞–µ—Ç—Å—è

      document.getElementById("initData").value = initData;

      const form = document.getElementById("uploadForm");
      const status = document.getElementById("status");

      form.addEventListener("submit", async (e) => {
        e.preventDefault();
        status.textContent = "üîÑ Authorizing...";
        status.innerHTML = ""; // Clear previous status and links

        const formData = new FormData(form);
        const initDataValue = formData.get("initData");

        try {
          // Get JWT token via initData
          const authRes = await fetch("/auth", {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: new URLSearchParams({ initData: initDataValue })
          });

          if (!authRes.ok) {
            const err = await authRes.text();
            status.textContent = "‚ùå Authorization failed: " + err;
            return;
          }

          const { access_token } = await authRes.json();

          status.textContent = "üîÑ Uploading audio...";

          // Remove initData before upload
          formData.delete("initData");

          // Always send speaker_labels=true
          formData.set("speaker_labels", "true");

          const uploadRes = await fetch("/upload", {
            method: "POST",
            headers: { "Authorization": `Bearer ${access_token}` },
            body: formData
          });

          const result = await uploadRes.json();

          if (uploadRes.ok) {
            status.textContent = "‚úÖ " + (result.message || "Upload successful!");

            if (result.transcript) {
              // Determine MIME type based on output format
              let mimeType = "text/plain";
              if (result.output_format === "markdown") mimeType = "text/markdown";
              else if (result.output_format === "srt") mimeType = "application/x-subrip";

              const blob = new Blob([result.transcript], { type: mimeType });
              const url = URL.createObjectURL(blob);

              const downloadLink = document.createElement("a");
              downloadLink.href = url;
              downloadLink.download = (result.filename || "transcript") + "." + (result.output_format || "txt");
              downloadLink.textContent = "‚¨áÔ∏è Download transcript";
              downloadLink.style.display = "block";
              downloadLink.style.marginTop = "10px";

              status.appendChild(downloadLink);
            }

          } else {
            status.textContent = "‚ùå Error: " + (result.error || JSON.stringify(result));
          }

        } catch (err) {
          status.textContent = "‚ùå Exception: " + err.message;
        }
      });
    });
  </script>
</body>
</html>
